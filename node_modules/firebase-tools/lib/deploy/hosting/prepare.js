"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unsafePins = exports.prepare = void 0;
const error_1 = require("../../error");
const api = require("../../hosting/api");
const config = require("../../hosting/config");
const deploymentTool = require("../../deploymentTool");
const functional_1 = require("../../functional");
const track_1 = require("../../track");
const utils = require("../../utils");
const backend = require("../functions/backend");
async function prepare(context, options) {
    if (options.public) {
        if (Array.isArray(options.config.get("hosting"))) {
            throw new error_1.FirebaseError("Cannot specify --public option with multi-site configuration.");
        }
        options.config.set("hosting.public", options.public);
    }
    const configs = config.hostingConfig(options);
    if (configs.length === 0) {
        return Promise.resolve();
    }
    const versions = await Promise.all(configs.map(async (config) => {
        const labels = Object.assign({}, deploymentTool.labels());
        if (config.webFramework) {
            labels["firebase-web-framework"] = config.webFramework;
        }
        const unsafe = await unsafePins(context, config);
        if (unsafe.length) {
            const msg = `Cannot deploy site ${config.site} to channel ${context.hostingChannel} because it would modify one or more rewrites in "live" that are not pinned, breaking production. Please pin "live" before pinning other channels.`;
            utils.logLabeledError("Hosting", msg);
            throw new Error(msg);
        }
        const version = {
            status: "CREATED",
            labels,
        };
        const [, versionName] = await Promise.all([
            (0, track_1.track)("hosting_deploy", config.webFramework || "classic"),
            api.createVersion(config.site, version),
        ]);
        return versionName;
    }));
    context.hosting = {
        deploys: [],
    };
    for (const [config, version] of configs.map((0, functional_1.zipIn)(versions))) {
        context.hosting.deploys.push({ config, version });
    }
}
exports.prepare = prepare;
function rewriteTarget(source) {
    if ("glob" in source) {
        return source.glob;
    }
    else if ("source" in source) {
        return source.source;
    }
    else if ("regex" in source) {
        return source.regex;
    }
    else {
        (0, functional_1.assertExhaustive)(source);
    }
}
async function unsafePins(context, config) {
    var _a, _b, _c;
    if ((context.hostingChannel || "live") === "live") {
        return [];
    }
    const targetTaggedRewrites = {};
    for (const rewrite of config.rewrites || []) {
        const target = rewriteTarget(rewrite);
        if ("run" in rewrite && rewrite.run.pinTag) {
            targetTaggedRewrites[target] = `${rewrite.run.region || "us-central1"}/${rewrite.run.serviceId}`;
        }
        if ("function" in rewrite && typeof rewrite.function === "object" && rewrite.function.pinTag) {
            const region = rewrite.function.region || "us-central1";
            const endpoint = (await backend.existingBackend(context)).endpoints[region][rewrite.function.functionId];
            if (!endpoint) {
                continue;
            }
            targetTaggedRewrites[target] = `${region}/${endpoint.runServiceId || endpoint.id}`;
        }
    }
    if (!Object.keys(targetTaggedRewrites).length) {
        return [];
    }
    const channelConfig = await api.getChannel(context.projectId, config.site, "live");
    const existingUntaggedRewrites = {};
    for (const rewrite of ((_c = (_b = (_a = channelConfig === null || channelConfig === void 0 ? void 0 : channelConfig.release) === null || _a === void 0 ? void 0 : _a.version) === null || _b === void 0 ? void 0 : _b.config) === null || _c === void 0 ? void 0 : _c.rewrites) || []) {
        if ("run" in rewrite && !rewrite.run.tag) {
            existingUntaggedRewrites[rewriteTarget(rewrite)] = `${rewrite.run.region}/${rewrite.run.serviceId}`;
        }
    }
    return Object.keys(targetTaggedRewrites).filter((target) => targetTaggedRewrites[target] === existingUntaggedRewrites[target]);
}
exports.unsafePins = unsafePins;
